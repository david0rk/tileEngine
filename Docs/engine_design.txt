TILE ENGINE DESIGN NOTES
Event driven.  Player input moves game logic and drawing. No animation/sound this time, maybe later though.
First game, probably going to be shit.
Roguelike/zelda sort of vibe? 
ARBITRARY GOAL FOR CHALLENGE AND FUN:  MUST RUN/BE PLAYABLE ON RASPI @ 640x480, MINIMUM. 

4 INDEPENDENT LAYERS
FLOORS (Floors/Water/Empty Space/Walls)
	DOORS (Doors/Holes/Fountains)
		SPRITES (Characters/Enemies/Items/Interaction)
			GORE (paperdoll/effects)
			A fifth layer for UI/menu could/should be added later completely independent from game logic (will use unified draw to redraw all. )

	Performance/implementation: SDL_RENDERCOPY for batching out texture at a time. Each layer is surface, composited out to main display.
	could make a surface for player to copy out (draw base char > draw armor on top once, hold in surface to copy out instead of draw player>draw armor every time the player moves) 
	example: void updateplayersprite (int tile id to paint) <draw to player surface>, then from there on unless player changes appearance just copy from player surface. 
	
	need to be able to swap column /rows efficiently.
	grab current screen, redraw 1 column/row offset, draw in new tiles> unified draw/coord system is essential for this. updatecolumn(n), updaterow (n) and combined updatecorner(row,col) 
	maybe this is an example of the mythical double buffering? 
	1 entire surface dedicated to being a copy of what is on screen, just for cheap redraws by shifting/rearranging and drawing just the new elements, CODE TESTS WILL HAPPEN!
	memory/processor tradeoff, may be key to getting to run on the pi, or getting the pi to run out of ram.
	
	o = old n= new  - = off screen
	Row swap example:
	nnnn	oooo
	----	----
	oooo	oooo
	oooo	oooo
	oooo	nnnn	
	----	----
	nnnn	nnnn

Each layer has a Draw function plus a Unified Draw function.
	unified draw function only updates things that need to change in relation to previous frame.
		ex: Character movement: unified draw sends sprite to new character position in sprites layer, sends redraw to floor layer @ old position. 
			Blank to draw over old pos in sprite layer?  (1 draw) or blank and redraw? (1 draw per sprite if so.)
11/7/15 1:00AM: BETTER IDEA: RENDER THE WHOLE DAMNED MAP IN ITS OWN SURFACE, CUT OUT THE PIECE THATS GONNA BE ON SCREEN. ONLY 1 DRAW CALL FOR THE BACKGROUND _PERIOD_ 

		
Mapping
	Map file is raw data array
		1byte hex in map file = 1 tile in map
			1byte = 255 possible tiles/options (could expand later, requires rework)
				Map includes door layer (ex:1 = dungeon floor, 21 = dungeon floor w/door overdrawn)
					Graphical editing tool later?
						passable/impassible tiles
							collision detection
								"viewport" can be smaller than map for scrolling. 
					

Unified grid/coord system
	Lots of math.  Standardize on sprite/tile size.
		screen width / tile width = horiz tile count. screen height / tile hight = vert tile count.
			so that coordinates are a simple array and we don't have to count pixels to move characters arround
				may need to implement black border if screen size is odd to get an even tile count
					drawing functions need horizontal & vertical offset values to keep shit centered
						Moving North/south/east/west feels like it should be a simple void. 
					
Character/entity tracking
	Struct/class for characters, must include entity id.  id 0 = player character
		increment id per new character entity, keep track of in a table.
		  For next to handle each entity per turn. (game logic happens between draws, player input pushes game forward)
			when entity dies, reclaim id  and pop entity table.
				clarification: entity is something that can act or move about
					should include health/location/releveant info for save/load purposes
						game logic should be separate from render code.
						
								
Input handling
	Intercept esc to keep from killing sdl. 
		Scancode table will be consulted like a motherfucker
			Some input should not affect game logic or affect drawing (menu's)
			
			
Art
	Not my skill :(
		Sprite sizes of 32 or 64 would be ideal for newer machines with high res displays, may need to ship different sizes for scaling 16/32/64.
			Sprites will be "enumerated" in code and correspond to a number and picked off the sheet. 
				Uniform size/spacing is a must
						Bitmap/tiled font for menus
							need to figure out color>transparency for layering and pick a standard "this color = transparency" for art guidelines


Dev notes:
Built with codelite on linux, should build on windows with no problems
Requires libsdl1.2-dev, gcc/g++ 
May wind up using c++11 standard, but so far not required.
Graphics tools used:
	
	gimp: used for stitching together individual sprites. Save as BMP > check additonal options > don't save colorspace info (causes funky colors). 
	libsdl handles 24bit bitmaps natively, needs libsdl-image or additonal libraries for jpeg/png gfx. 
	(art.bmp is actually what the game uses, it is floor.bmp and char.bmp stitched together.)


Put graphics (BITMAP!) in the debug folder for the game to pick them up at runtime. 

ingame editor for quick/easy testing. 
output to stdout (need game window/debug window seperate, if not running in development environment, launch game from batch file so that a command window is left open with the game running in foreground)
press e to switch to edit mode.  N to create new map (sizes are base2 squares, ex: 16 = 16x16 tile map  256 = 256x256 tiles/ this will be added to map format (header to tell engine how many tiles to read)) 
generates new map array, array elements initialized to tile 0 > use tilecutter sort of interface to edit/design maps. will need a player start tile, if not specified assumes 0,0. 
press e again to go back to play mode.
filenames specified through stdout window (pressing save asks for filename @ cmdline window and is entered there)


Gameplay
	Static maps (maybe randomized/lego assembled from prefab parts later) maybe clone dungeons from a link to the past? 
	fixed enemy spawn locations (maybe randomized later)
	Health/hitpoint calculation:
		( (basehp * level) * (1 + (levelbonuspercent*level) ) ) + (ArmorDefense * (1+echantProtectionPercent))
		base hp of 5, level 2 character example 25% bonus in HP per level, 10d armor with enchant bonus of 50%
		=  (5 * 2) * (1+(2*.25)) + (10) * (1+(.50) 
		=  (10 * 1.5) + (10 * 1.5)
		=  15+15
		Max hp = 30
	Attacks will use RNG, characters will have minimum and max attack damages as range for RNG.
	Attack damage should like HP be based on level, but the level bonus should be minor.  Multiplied out via item.
	why: a good low level weapon should need to be replaced with a better weapon as the game goes on. lvl 1 weapon may be 2x multiplier over players lvl damage. level 10 or rare item should be much higher multiplier.
	possibly a minimum level/stat requirement for weapons? you are too weak to wield megahammer of ass smashery!
	CLASSLESS = FUN. Just because i'm  not a knight shouldn't mean i can't swing a sword. just because i'm not a wizard doesn't mean i cant point a wand. Let the player decide how they want to do stuff.	
